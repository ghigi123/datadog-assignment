/*
 * This file defines TimeSeries and Metric classes
 * TimeSeries is the dataStructure part
 * Metric is the organisational and math part
 */

// IMPORTS

const _ = require('lodash');

// HELPERS

// This binary search does not look for a value, but for a position at which
// a given value should be inserted to keep the list ordered.
const binarySearch = (array, search, predicate) => {
    let minIdx = 0;
    let maxIdx = array.length - 1;
    if (maxIdx === -1 || predicate(search) >= predicate(array[maxIdx])) {
        return array.length;
    }
    while (minIdx < maxIdx) {
        const curIdx = Math.floor((minIdx + maxIdx) / 2);
        if (predicate(array[curIdx]) <= predicate(search)) {
            minIdx = curIdx + 1;
        } else {
            maxIdx = curIdx;
        }
    }
    return minIdx;
}

// This helper simply insert a value in an ordered array.
// I have chosen an array to store time series because it
// is quite efficient for the following reasons :
//  - the values are normally pushed in timestamp order
//    but I wanted to handle the case when an older value
//    is pushed to the time serie. The way I have chosen to
//    make http requests and store the start time uses this.
//  - I made the assumption than even if a unordered push
//    can occur, it will be rare, and always not that far from
//    the end of the time series : the in place `splice` function
//    is escpeccially well fitted to this, as it will only change
//    the very end of the array

const orderedInsert = (arr, obj, predicate) => {
    arr.splice(
        binarySearch(arr, obj, predicate),
        0,
        obj
    );
}

/*
 * This stores a time series in an Array<{timestamp: number, value: any}>
 */

class TimeSeries {
    constructor() {
        // we will keep this array sorted by timestamp
        this.entries = [];
        this.pushCallbacks = [];
    }

    slice(startTimestamp, endTimestamp) {
        return _.slice(
            this.entries,
            binarySearch(this.entries, { timestamp: startTimestamp }, o => o.timestamp),
            binarySearch(this.entries, { timestamp: endTimestamp }, o => o.timestamp),
        );
    }

    push(obj) {
        // let's insert it at the right position
        // we're using splice combined with binary search
        orderedInsert(this.entries, obj, o => o.timestamp);
        this._push(obj);
    }

    _push(obj) {
        _.forEach(this.pushCallbacks, callback => callback(obj));
    }

    onPush(callback) {
        this.pushCallbacks.push(callback);
    }
}

/*
 * This stores a metric
 * This is for now quite basic, but we could easily imagine some interesting features
 * in this class, such as dependencies between metrics, grouping metrics, autoremove
 * old values based on dependencies.
 * This could also be a naive approche to temporal resolution of time series
 * 
 * For now :
 *  - a Metric can be a real metric, or generated by an aggregator
 *  - we can compute on a slice :
 *            sums, averages, mins, maxs, weigted averages, counts
 *    on :
 *            numbers, strings, maps
 * 
 *    for instance summing a timeserie of COUNT (which are maps) is possible and will distribute
 *    the operation to the fields
 */

class Metric {
    constructor(name) {
        this.name = name;
        this.timeSeries = new TimeSeries();
        this.pushCallbacks = {};
    }

    on(event, id, callback) {
        if(event === 'push') {
            this.pushCallbacks[id] = callback;
        }
    }

    deleteCallback(event, id, callback) {
        if(event === 'push') {
            delete this.pushCallbacks[id];
        }
    }

    _triggerCallbacks(event, value) {
        if(event === 'push') {
            _.forEach(this.pushCallbacks, callback => callback(value));
        }
    }

    aggregate(aggregationType, aggregationTime, timestamp) {
        const slice = this.timeSeries.slice(timestamp - aggregationTime, timestamp);

        // this function simply wraps the lambda function defining the calculus to a map
        // if necessary, to for instance sum couts of another aggregation
        const objectWrap = (slice, lambda, neutral) => {
            const timestamps = _.map(slice, 'timestamp');
            const values = _.map(slice, 'value');

            if (typeof (values[0]) === 'object') {
                const objKeys = _.uniq(_.flatten(_.map(values, o => _.keys(o))));
                const objValues = _.map(objKeys, key => {
                    const extracted = _.map(values, val => val[key] !== undefined ? val[key] : neutral);
                    return lambda(timestamps, extracted);
                });
                return _.zipObject(objKeys, objValues);
            } else {
                return lambda(timestamps, values);
            }
        }

        // here is where we define our operations
        // ts stands for TimestampS
        // vs stands for ValueS

        switch (aggregationType) {
            case 'AVG':
                // computes average
                return objectWrap(slice, (ts, vs) => _.sum(vs) / vs.length, 0);
            case 'SUM':
                return objectWrap(slice, (ts, vs) => _.sum(vs), 0);
            case 'MAX':
                // computes maximum
                return objectWrap(slice, (ts, vs) => _.max(vs), Number('-inf'));
            case 'MIN':
                // computes minimum
                return objectWrap(slice, (ts, vs) => _.min(vs), Number('inf'));
            case 'AVG_TIME':
                // computes time weighted average

                /* 
                 * there is one more timestamp than duration, so i make the choice to
                 * drop the last timestamp and associate a duration with the start timestamp
                 * t1 d1 t2 d2 t3
                 * avg_time = (v(t1) * d1 + v(t2) * d2) / (d1 + d2)
                 *
                 * we could also take the middle value for each duration, but let us assume
                 * than if the user really wants more precision he will shorten the time frame
                 * this way the computation is simpler
                 * avg_time_alt = (v2(t1, t2) * d1 + v2(t2, t3) * d2) / (d1 + d2)
                 * with v2(t1, t2) = (v(t1) + v(t2)) / 2
                 */

                return objectWrap(slice, (ts, vs) => {
                    const durations = _.map(
                        _.range(ts.length - 1),
                        idx => ts[idx + 1] - ts[idx]
                    );
                    if(durations !== 0) {
                        return _.sum(_.map(durations, (d, idx) => vs[idx] * d)) /
                        _.sum(durations);
                    } else {
                        return vs[0];
                    }
                }, 0);

            case 'COUNT':
                return objectWrap(slice, (ts, vs) => _.countBy(vs), {});
        }
    }

    push(obj) {
        this.timeSeries.push(obj);
        this._triggerCallbacks('push', obj);
    }
}

module.exports = {
    TimeSeries,
    Metric
};
